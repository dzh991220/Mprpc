# Mprpc
## 项目说明
该项目是在 Linux 环境下基于 muduo、Protobuf 和 Zookeeper 实现的一个轻量级 RPC 框架。可以把单体架构系统的本地方法调用，重构成基于 TCP 网络通信的 RPC 远程方法调用，实现统一台机器不同进程或者不同机器之间的服务调用。

## 项目特点

- 基于 muduo 网络库实现高并发网络通信模块，作为 RPC 同步调用的基础。
- 基于 Protobuf 实现 RPC 方法调用和参数的序列化和反序列化，并根据其提供得 RPC 接口编写 RPC 服务。
- 基于 ZooKeeper 分布式协调服务中间件提供服务注册和服务发现功能。
- 设计了基于 TCP 传输的二进制协议，解决粘包问题，且能够高效传输服务名、方法名以及参数。

## 开发环境

- 操作系统：`Ubuntu 18.04.6 LTS`
- 编译器：`g++ 7.5.0`
- 编辑器：`vscode`
- 版本控制：`git`
- 项目构建：`cmake 3.10.2`

## 构建项目

运行脚本，其会自动编译项目

```shell
bash autobuild.sh 
```

## 如何使用

### 启动 zookeeper

我们需要在 zookeeper 上获取注册的服务信息，因此先必须保证启动了 zookeeper。我的 zookeeper 目录在 `/home/shang/thirdparty/zookeeper-3.4.10`。

在里面的 `bin` 目录下有客户端和服务端的启动脚本，先启动 zookeeper 服务。

```shell
root@iZwz9eojvzsrz78f673t51Z:# ./zkServer.sh start
```

此时可以在进程中查找到 zookeeper

![img](https://cdn.nlark.com/yuque/0/2022/png/26752078/1665126405491-abb39072-26ef-482d-aa98-eff0b338fe21.png)

再启动服务端脚本，启动客户端主要是为了看是否会因为我们的 RPC 框架插入新服务信息。

```shell
root@iZwz9eojvzsrz78f673t51Z:# ./zkCli.sh
```

### RPC 框架的示例

在 `bin`目录下有客户端和服务端两个文件，分别启动。

```shell
client  server  test.conf
```

### 启动服务端

```shell
./server -i test.conf
```

我们观察下打印的信息，可以看到它打印了 `test.conf` 配置文件的信息，至少说明 RPC 框架读取配置是成功的。

![img](https://cdn.nlark.com/yuque/0/2022/png/26752078/1665126529669-699ea4c3-4a91-4839-9a89-f374b839bf40.png)

重点是下面的信息，其显示在 zookeeper 上注册了服务。

![img](https://cdn.nlark.com/yuque/0/2022/png/26752078/1665126654779-03fd180a-32c2-429e-8196-242c464c348b.png)

我们去 zookeeper 上查看是否真的插入了新服务，发现确实如此。

![img](https://cdn.nlark.com/yuque/0/2022/png/26752078/1665126668882-548ef033-0dcc-4f3c-bcd9-fec1a485e3d5.png)

### 启动客户端

```shell
./client -i test.conf
```

有很多的提示信息，也是解析了配置文件，并且有许多 zookeeper 相关日志信息。这里注意最重要的几个地方，它打印显示了 `rpc Login response success:0`。响应为 0，RPC 方法调用成功！

![img](https://cdn.nlark.com/yuque/0/2022/png/26752078/1665126722724-17ce8451-fab4-46e3-9b71-c935309bb89f.png)

## 项目分解
1、单机，集群和分布式
集群：每一台服务器独立运行一个工程的所有模块。

分布式：一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工作共同提供服务，每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。

我们以服务聊天器为例子，来讲解单机，集群，分布式
单机服务器

在这里插入图片描述
聊天服务器取名为server。
把用户管理，好友管理，群组管理，消息管理，后台管理等模块构成我们的聊天服务器。每个模块都包含了很多特定的业务。特定的业务：用户管理模块有用户登录，用户注册，用户注销，用户退出等功能业务。好友管理有添加好友，删除好友等功能业务。群组管理有添加群，创建群，解散群，群里踢人等功能业务。消息管理有离线消息，一对一的消息，群组消息等和功能业务。后台管理有广播消息，公告消息，活动消息等功能业务。

单机版的服务器的性能，瓶颈？
1、受限于硬件资源。因为我们只有一台服务器，聊天服务器所能承受的用户的并发量是有限的。假设我们使用32位linux，给一个进程把资源开满，最多支持2万多人的在线。用户量上不去了。硬件资源不够，socket资源不够。
2、任意模块的修改都会导致整个项目代码重新编译，部署。假设这个服务聊天器有5个模块，每个模块有几十上百个功能业务，这一套项目编译得花2个小时，部署得花3个小时。现在如果我们突然发现用户管理模块有个注销的业务里面有bug，但是改起来特别简单，就几行代码。但是这是一整套系统，得把整个项目的所有代码全部重新编译！！！这样又得花2个小时编译，运维部署3个小时！！！
3、系统中有些模块是属于CPU密集型（计算量大的），有些模块是属于I/O密集型的（接触 输入输出，网络I/O），造成各模块对硬件资源的需求是不一样。 有些模块是CPU密集型的，这些模块应该部署在CPU资源非常好的机器上，有些模块是I/O密集型的，这些模块应该部署在内存大，带宽好的机器上，不需要太强的CPU资源。不同模块属于不同的型，对硬件的需求不一样，打包在一套机器上，只能综合所有模块，提出平衡的供给需求，没办法针对性。
集群

操作简单，遇到双11，并发量上来了，直接扩充机器数量，加个负载均衡器。
每一台服务器独立运行一个工程的所有模块。
在这里插入图片描述
我们扩充了硬件资源。在水平方向上直接扩充成3台机器。每个机器独立运行着一台聊天服务器程序。
假如server2出问题，不影响聊天，因为server1和server3还可以独立地提供聊天服务，因为是独立的服务器。

但是每一台机器都还是独立运行着一套聊天服务器系统程序，现在对任意模块的修改，得把整套代码重新编译，因为模块根本没有分开去部署，都是在一个项目中部署，运行在一个服务器进程中。
编译一套代码，做多次部署。因为我们扩充成3台机器了！

集群的优点？
性能提升了，用户的并发量提升了，因为水平扩充了硬件资源。
集群的缺点？
1、项目代码还是需要整体重新编译，而且需要进行多次部署。
2、系统中有些模块是属于CPU密集型（计算量大的），有些模块是属于I/O密集型的（接触 输入输出，网络I/O），造成各模块对硬件资源的需求是不一样。

并不是说机器多，并发量就上来，性能就高。
像 后台管理 模块，这个模块使用的用户是不多的，能在聊天系统上发布公告，只有管理员，像学校的校长才能发布公告，而且后台管理员根本不需要高并发，但是把这个模块部署在3台机器上，就太浪费了！！！，像这些不常用的模块只需要部署在一台机器上就好啦，接下来我们讲解分布式！！！
分布式

分布式：把这些管理模块抽出来，单独部署在不同的机器上。
从集群上看的话，server2挂掉，还有完整的聊天服务器系统server1,server3。
但是在下图的分布式上，对于红色圈，3台机器上分别运行着不同的模块，少了这3台机器的任意台，聊天系统就缺失了相应的业务了！！！所有机器共同构成一个聊天服务器系统。这就是分布式。
在这里插入图片描述

一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工作共同提供服务，每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。

分布式的优点？
1、
用户登录成功，为了支持登录的并发量，我们可以把分布式节点1集群，扩充机器来部署运维用户管理，消息管理。
在这里插入图片描述
比如说后台管理这个模块不需要高并发，一台机器足以！！！

甚至我觉得用户管理（登录，退出）需要更多的并发量，没有人整体加好友删好友，建群，解散群。我们可以在server2节点上再部署用户管理，消息管理这2个业务功能。
在server2中，当好友管理和群组管理无法使用完server2的网络I/O资源的时候，用户管理和消息管理可以再享受多余的server2的网络I/O资源提供给更多的客户端进行登录登出的聊天服务。
在这里插入图片描述
2、假设后台管理模块出问题，我只需要把server3这台机器的后台模块重新更新就可以了，其他模块不需要更新。
3、把CPU密集型的模块部署在CPU资源好的机器上。把内存小的模块部署在硬盘资源少的机器上。把I/O密集型的模块部署在CPU不是很好的机器上。
有的模块要求并发能力高，可以进行多机器集群部署。有的模块并发能力小，部署在一台机器就可以。

配置着高可用，容灾，主备服务器，不用担心就一套系统挂掉了怎么办。
分布式面临的问题

1、大系统的软件模块该怎么划分？
各模块可能实现大量重复的代码！
模块和模块之间的界线不清晰（有的模块里面的函数调动另一个模块的函数代码）。
处理不好，造成大量重复代码。而且你改你的，我改我的，重复的公共代码就出问题了，变成不可控制了。
2、各模块之间该怎么访问？
各模块可能运行不在一个机器上，或者不在一个进程上。
在这里插入图片描述
如果用户登录成功了，想展示好友列表，但是用户管理模块只负责用户的登录，退出，修改密码等业务功能，它并不知道好友列表，负责管理好友的是好友管理模块。通过传入用户id，得出好友列表。在单机或者集群中，这些模块是运行在一个服务器进程当中，相当于自己调用自己。但是在分布式中，用户管理和好友管理部署在不同的进程中，用户管理进程如何调用另一个模块上的业务呢？

机器1上的模块怎么调用机器2上的模块的一个业务方法呢？
机器1上的一个模块进程1怎么调用机器1上的模块进程2里面的一个业务方法呢？
通过网络！ 处理网络请求。网络是否有问题？如何告诉调用者网络的情况？

2、RPC通信原理和项目解析
RPC（Remote Procedure Call Protocol）远程过程调用协议
在这里插入图片描述
黄色部分：设计rpc方法参数的打包和解析，也就是数据的序列化和反序列化，使用Protobuf。
绿色部分：网络部分，包括寻找rpc服务主机，发起rpc调用请求和响应rpc调用结果，使用muduo网络库和zookeeper服务配置中心（专门做服务发现）。
mprpc框架主要包含以上两个部分的内容。
解析上图（RPC通信图解）

左边的caller，就是调用者。相当于下图的server1这个角色，用户管理，用户发起的一个远程的方法调用，获取当前指定用户id的好友列表。上图的local call对应的状态就是server1用户管理的这个进程调用GetUserFriendList函数，这是一个远程的RPC方法，不是一个当前进程内的方法，首先得去服务配置中心查找，知道这个服务在server2里面，现在就是要把这个函数调用的请求通过网络发布到server2中，server2还得知道你要调用哪个函数！因为server2有很多模块，很多RPC方法。所以我们在传输的时候要把 函数的标识，方法在远端调用涉及到的参数进行打包。这就是对应上图的pack argument，打包参数，我们称作序列化。序列化好之后，我就可以把这个请求通过网络transmit传送过去到server2中，网络是用C++实现的开源的muduo库。
远端接收到从网络接收到RPC调用请求（对应上图的receive)，从网络底层上报上来，上报上来的是打包完成后的参数，这时要把从网络接收的打包的参数解包，对应上图的unpack argument，我们称作反序列化，就是把从网络的接收的字节流反序列化成具体的RPC调用的细节信息，方法，标识，参数，然后就到server2上了，对应上图的call。
此时，RPC的请求已经到达server2的好友管理的获取好友列表的函数上了，就是在机器的这个进程里执行这个list< User>GetUserFriendList函数，对应上图的work（工作，执行），然后return 返回值，不管是正常运行还是出错了，return 返回相应的东西，这时进行pack result，打包参数，即序列化成字节流，通过网络muduo库发到caller端。caller端收到后，即对应上图的receive，这个网络就会把字节流上报到User-stub上，把字节流反序列化，即对应上图的unpack result，反序列化后，就可以得到具体的应用程序可以认得的一个描述RPC调用方法请求的结果的数据，相当于上图的local return。
在这里插入图片描述
在这里插入图片描述
在分布式通信框架中，都有桩，stub就是“桩“，我们可以认为就是一个”代理“，因为RPC调用的发起方只需要关心业务，不用关心底层的网络上的RPC方法，通信的细节，细节都包装在stub，做数据的序列化和反序列化，网络数据的收发。执行RPC请求的这一端也是如此。
再举个例子

RPC方法：bool login(string name,string pwd)；
调用这个方法，是远程调用另一个进程。
在这里插入图片描述
首先，我们在Caller的User，local call，发起login()；
需要框架的User_stub把我想调用的RPC的方法的方法名字，参数序列化，打包起来形成字节流，通过网络进行发送(使用muduo库）,发送到对端以后，对端receive，接收从网络得到的字节流，然后在Server-stub把字节流反序列化出来，然后根据解包的参数进行调用相应的函数。work调用执行，return登录执行的结果true或者false，有可能在执行的时候函数执行出现问题，我们可以在返回的东西中还可以加一些响应，响应码是0，表示这个方法在远端执行是正常的，如果执行错误，就返回一些信息（响应码，错误码，错误信息，具体的返回值）。然后经过打包（pack result）成字节流通过网络发送（muduo库）到对端。然后端端receive，在User-stub解包，反序列化，上报到应用程序，就知道了，根据返回的信息进行相应的操作。
我要完成的 基于RPC的分布式网络通信框架 项目就是完成下图的所圈起来的部分

在这里插入图片描述
黄色部分，我将用protobuf完成，json也可以完成，但是protobuf相当于json的好处：
1、protobuf是二进制存储，xml和json都是文本存储！！！
二进制省空间！
protobuf在携带数据的时候，带宽的资源的利用率是高的。protobuf携带同样的数据，占用的字节少！
2、protubuf不需要存储额外的信息，
json的存储是：key-value
name ：“zhangsan" pwd:“123456”
而protobuf的存储是：“zhangsan" “123456”，它只存储有效数据！！！




## 项目优化

- 引入 Nginx 负载均衡模块
- 封装 RPC 连接池，重用连接
- 增加 Router 层次，在 RPC 服务的众多服务器集群中选择某一节点
